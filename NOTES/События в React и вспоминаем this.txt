Для того, чтобы назначить событие, нужно добавить код в формате camelCase, например, onClick.
Например, как было вот здесь.

<button onClick={this.nextYear}>+++</button>

тут я пробую в инпут добавит событие onInput, которое будет отслеживать приходящие символы и 
потом добавлять их в состояния, чтобы они где-то в классе например учитывали и позже 
выводились сразу в верстку 

В реакте события change и onInput работают одинаково , в js нативном change срабатывает когда уводится 
фокус от этого элемента , а input срабатывает сразу же как мы ввели эти символы , но повторюсь в реакте они 
работают одинаково, НО нужно запомнить что в реакте стоит использовать onChange={}

добавил onChange={this.commitInputChanges} в инпут, сейчас он выглядти вот так 

<input type='text' onChange={this.commitInputChanges} />

Он находится в форме, а эта форма часть другой небольшой верстки с примерами, где я работал с деструктуризацией 
пропс и потом выводом их по типу name, surname и {this.state.years}

Теперь нужно обработчик этот сделать 

commitInputChanges = (e) => {
    console.log(e.target.value) - таким способом я смогу узнать на каком элементе произошло событие 
}

Теперь когда ввожу какие-то символы в input - они выводятся в консоль , так же это значение которое я получаю 
из обработчика события я сразу могу получить и работать с ним, по этому я добавлю его в конструктор

class WhoAmI extends Component {
    constructor(props) {
        super(props);
        this.state = {
            years: 27,
            position: ''
        }
    }
}

Мне не важно какое значение находится сейчас в position на данный момент, мне важен только конечный результат 
по этому я беру

Некст йеарс это пример передачи нового значения, где нам важно предыдущее из-за этого оборачиваю в стрелочную функцию, 
а ниже будет работа с объектом без неё, и вот наглядно 2 примера как можно работать с и без

nextYear = () => {
    this.setState(state => ({
        years:state.years + 1
    }))
}

Без

commitInputChanges = (e) => {
    this.setState({
        position: e.target.value
    })
}

и чтобы сразу наблюдать изменения , я сразу буду выводить это в верстку 
<h1>My name is {name}, surname - {surname}, age = {this.state.years}, position = {this.state.position}</h1>

И для оптимизации нужно вывести 2 этих переменные из объекта state , для удобства 
Далее мы так будем делать всегда 

const{position, years} = this.state;

И после этого можно убрать this у элементов position и years

Сохраняю такой код и теперь смотрю , что когда ввожу символы в инпут они отображаются в строку куда я выводил их в верстку 

адвансевентлисенер вызывать нигде не нужно, реакт все делает за нас , ещё есть такой ограниче что для отмены стандартного поведения браузера 
мы должны использовать евентпревентдефолт , потому что такие методы как ретёрнфалс в реакте работать не будут только превентдефолт

-------------- 

ТЕПЕРЬ ИНФОРМАЦИЯ ВАЖНЕЕ И СЛОЖНЕЕ 

Почему до этого учитель просил использовать стрелочные функции вместо обычных 

на момент записи урока такой синтаксис является эксперементальным , но он отлично работает в связке с babel , но официально уже подтверждено 
что он войдет в разработку в 2022 году 

вобщем - все дело в контексте вызова this , нужно обратить внимание, что когда мы передаем что либо в обработчик события мы всегда используем 
this для указания экземпляра класса , так же для props и state 

Есть сложно понять о чем говорит учитель, то можно перейти на страницу и можно увидеть что он создал 2 экземпляра класса которые отвечают за 
Смита и Алекса - ЭТО ОТДЕЛЬНЫЕ СУЩНОСТИ КОТОРЫЕ ОТПАЧКОВАЛИСЬ ОТ класса который мы создали 
this указывает конкретно на один экземпляр класса, чтобы у каждого элемента были свои свойства 

Чтобы в этом убедиться окончательно , в консоль можно вывести this , 
и в консоле мы видим 2 отдельных компонента , если их раскрыть мы увидим разницу 

Когда мы тут работаем со state и props - здесь довольно все просто потому что this всегда будет ссылаться на этот экземпляр 
но вот с обработчиками событий все чуть сложнее когда событие срабатывает - контекст терояется 
Это происходит из-за того что функция вызывается внутри какого-то другого медода и соответственно this у на становится undefined 
чтобы в этом убедиться мы можем взять 

nextYear , который был у нас стрелочной функцией и переработать его в обычный метод убрав оттуда стрелочную функцию 
теперь когда пробуем увеличить число через этот метод - все ломается и в консоли пишет что мы не можем чистать свойство undefined 
когда происходит событие setState - это значит что контекст потерялся на этом этапе 

функция setState вызывается внутри nextYear , nextYear вызывается внутри Render и в итоге мы теряем контекст 

Сейчас мы разберем 3 примера как этого избежать , каждый из этих примеров я буду встречать в работе 

Первый вариант классический через конструкцию bind 

В конструкторе мы обращаемся к this , экземпляру класса - когда он уже будет создан используя bind 


class WhoAmI extends Component {
    constructor(props) {
        super(props);
        this.state = {
            years: 27,
            position: ''
        }
        this.nextYear = this.nextYear.bind(this)
    }
}

Выглядит страшно но, если разобраться то не так уж и 

слева находится обычное свойство которое уже будет у экземпляра класса который уже был создан 

справа у нас идёт что мы обращаемся к this.nextYear к метожу который есть в классе и мы его биндим , 
привязываем к конкретному экземпляру класса 

если простыми словами вот екземпряр класса, мы берем и настоящего твоего класса этот метод и просто привязываем его 
к тебе жестко чтобы ты никогда не терял this

Если будет увеличиваться количество методов с которыми мы работаем в обработчиках событий - их прийдется все биндить 
и это немного не совсем удобная консрукция

Удобнее вот эта, експерементальная на год выхода ролика конструкция ( использования полей классов которыми сейчас все пользуются)
Это и есть то чем мы пользовались - стрелочными функциями 


И сейчас когда учитель нажимает на кнопки в консоль выводится компонент, перередывается заново 


Существует 3 способ как это можно так же сделать , чтобы не терялся this , для этого так же понадобится функция обычная 
Это вызвать событие через анонимную стрелочную функцию 

nextYear() {
    this.setState(state => ({
        years:state.years + 1
    }))
}

Ставлю в обычную функцию и там где обработчик события делаю вызов через анонимную 

Выглядит это внутри кнопки вот так 

<button onClick={() => this.nextYear()}>+++</button>

Теперь когда произойдет клик по этому элементу , запустится функция 

() => this.nextYear() это все одна функция 

Внутри неё она запустит this.nextYear()

И за счёт того что this , она берет у своего родителя как из-за этого она получит ссылку 
на использование того объекта то есть на экземпляр класса 

Этот синтаксис тоже будет применяться , но есть одна проблемка, каждый раз когда будет создаваться компонент WhoAmI, то будет и создаваться новый колбек 
тоже самое касается и setstate , каждый раз когда у нас создается render() , каждый раз у нас создается и callback 

Проблемы могут начаться если этот колбек передается где-то дальше по иерархии в виде props 

Вот такую структуру () => this.nextYear() - она каждый раз создавалась бы заново 

Если у такого компонента поменяется props , то это заставит его перерисоваться и мы потеряем немного по оптимизации 



Иван хочется разобраться ещё один момент 

Как мы знаем когда вызывается setstate вызывается и render , и перерисовываются те элементы которые нужно перерисовать 

Допустим у нас есть h1 в компоненте и в нем перерисовались years и position , тогда изменится только h1, а другие элементы в 
этом компоненте затронуты не будет, это касается только элемента в котором произошло изменение 

------------

С помощью 3 способа когда мы его используем мы можем добавить аргумент, что нельзя сделать в других

в input пи добавляем стрелочную функцию 

<input type='text' onChange={(e) => this.commitInputChanges(e, 'some color')} />

<input type='text' onChange={this.commitInputChanges} /> - заместо этого 

И так же переписана должна быть функция 

commitInputChanges = (e, color) => {
    console.log(color);
    this.setState({
        position: e.target.value
    })
}

И теперь после этого я получаю color , с которым могу работать

