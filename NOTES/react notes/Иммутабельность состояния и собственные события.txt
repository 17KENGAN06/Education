Логично когда мы удаляем сотрудника у тебя с верстки он должен удалиться из сервера тоже , последнего мы конечно ещё не умеем.

Задача такова, когда нажимаю на корзинку удаляется пользователь и перерисовывается только часть приложения ,

В файл employers-list.js я должен передать пропсы, в <EmployersListItem/> где уже хранится key и itemProps я создам 
onDelete={} , внутри будет функция вызванная пользователем , там будет простая стрелочная функция которая будет выводить в консоль 
deleted , т.к функция передана в листе - мы её можем использовать в employers-list-item , теперь в пропсы передаю onDelete, который я 
передавал ниже по иерархии 

Далее я ищу кнопку которая отвечает в JSX за удаление и назначаю её обработчик события 
onClick={onDelete}

Теперь когда кликаю на иконку удаления в консоль выводится Deleted 

Потом перехожу в app.js и передаю в <EmployersList/> onDelete={id => console.log(id)}
Понятно , если мы какому-то компоненту передали такое свойство - то мы можем сохранить 
и вот здесь в const EmployersList = ({data, onDelete}) => {} то есть вытаскиваем тот проперти который у меня появился передавая значение вниз 
и теперь я мог использовать эту функцию в <EmployersListItem/> передав туда её и раз там она выводится с каким то аргументом
здесь мы тоже можем вызвать её тоже с каким-то - передав его во внутрь функции , т.д у меня здесь есть уникальный идентификатор , я могу его передать сюда 
во внурь функции и так будет происходить на каком элементе проводится действие именно 

И теперь в консоль будет при клике по корзинкам выводится id элемента - правильный и уникальный 

То что я сейчас сделал - это называется передача проперти, передача свойств компонентов по иерархии 

Подытог 

Я передал с самого верхнего элементов в app.js , взял какие-то данных data={data} , создал функцию 
onDelete обозначил и передал ниже ,  а далее в employers-list.js передал как props  и после смог эти данные 
переданные использовать передав ещё ниже в <EmployersListItem/> добавив туда onDelete={() => onDelete(id)}

Причем на данном этапе я её вызвал даже с уникальный единтификатором который есть в деструктуризированном виде в этих данных

И понятно что она у нас будет вызываться на самом нижнем уровне на этой кнопке и таким способом можно передавать и данные и все что угодно 

Теперь хорошо было бы приступить к удалению по клику из массива в app.js , сразу я сделать это не смогу 
ибо нужно помнить что динамически с данными можно работать только когда они находятся внутри state 

а для этого нужно самый главный компонент App в файле app.js переделать на класс 

а именно импортировать поведение компонента, после переписать с функции на класс , добавить конструктор и поместить JSX в render 


На файлах Ивана можно заменить что он любит структуру, где сначала идет импорт компонентов с реакта, потом файлов компонентов реакта 
и потом css классы 

Вобщем как я и написал више , переписываю на классы, по стандарту, если что-то будет иное я буду добавлять

Вот например массив data я должен поместить в state 

this.state = {
    data: [
        {name: 'John C.', id: 1},
        {name: 'Alex M.', id: 2},
    ]
}

data у него я должен убрать равно и переделать как в примере выше на двуиточие и в конще 
где закрывается точку с запятой.

После этого уже в <EmployersList/> в главном файле я передаю не просто data, а состояние 
data={this.state.data}, когда сохраняю ничего не должно поломаться все должно работать 

Теперь нужно создать метод, ниже конструктора, т.к он будет повторяться и чтобы каждый раз не рендерился был 
выше рендера 

deleteItem = (id) => {
    console.log(id)
}

и после этого когда я перехожу в EmployersList и иду к методу onDelete={}
туда я передаю this.deleteItem

тестирую приложение и вижу что там до сих пор ничего не сломалось 

Теперь , если я хочу хочу удалять какой-то элемент , я должен это деать в this.setState

deleteItem = (id) = > {                    - напоминаю пишется ниже конструктора где и данные пользователей
    this.setState(({data}) => {

    })
}

Задача взять этот уникальный идентификатор и по нему найти элемент в массиве чтобы его удалить 
после этой операции будет изменять state 

deleteItem = (id) = > {                    - напоминаю пишется ниже конструктора где и данные пользователей
    this.setState(({data}) => {
        const index = data.findIndex(elem => elem.id === id);
        console.log(index)
    })
}

Почему сначала ищут id, а потом получают index

В React мы:

Передаём id (он стабильный)

Через findIndex находим текущую позицию в массиве

const index = data.findIndex(elem => elem.id === id);


Потому что:

id — надёжный способ найти объект

index — нужен, чтобы удалить его из массива

-------------- 

Теперь задача удалить его при клике, мы знаем что напрямую через this.state нельзя меня элемент , 
мы можем его только мутировать 

Не изменяеммым или не иммутабельным - называется элемент который не может быть изменен после его создания 
появился у нас элемент в коде и никакие изменения мы не можем внести в нем 

Дабы у меня получилось то что я хочу (удалить его), я могу создать копию нашего стейта уже с внесенными нововедениями 
Такой подход с иммутабельность дает большие плюсы, сравнивая оба массива мы можем увидеть отличия и это отлично подходит для 
алгоритмов сравнения 

При таком подходе есть небольшие минусы ибо создают новые и новые копии - но это не такая уж и большая цена если учесть 
современные девайсы

Прямое изменение объекта state действительно вызывает очень много багов если я так оставлю 

Если я захожу удалить теперь элемент используя 

deleteItem = (id) = > {                   
    this.setState(({data}) => {
        const index = data.findIndex(elem => elem.id === id);
        data.splice(index, 1);
    })
}

Берется массив и удаляется индекс ( из переменной что помещается) и 1 значит что только один элемент

Это как бы очень простое удаление и после возращается с помощью return 

return {
    data: data
}

Теперь мы видим что оно что-то удаляет - но делается это с багами ибо мы изменяем state напрямую 
мы его мутировали методом splice 

Метод splice - именяет элементы массива удаляя или добавляя новые ( ИЗМЕНЯЕТ )


-----------------

На неправильный вариант я посмотрел - теперь как делать правильно 

Задача сейчас создать массив который будет хранить все такие элементы и потом сравнить 

Первый метод более длинный 

Я беру 
const before = data.slice(0, index)
const after = data.slice(index + 1)

И из них создаю новый массив 

const newArr = [...before, ...after]; 

Разворачивая их я получаю тот же массив с теми же данными что и были раньше но без того элемента что удалился

И теперь возвращаем 

return {
    data: newArr
}

После применения этих изменений все работает корректно 

Такой метод не всегда удобен - ибо у нас аж 3 строки кода, сейчас учитель покажет иной способ 
Где все легче и быстрее 

return {
    data: data.filter(item => item.id !== id)
}

Итог

Создаётся новый массив
Старый массив не мутируется
Элемент с нужным id удаляется

И конечно же если мы не используем slice , то и const index нам не нужен 