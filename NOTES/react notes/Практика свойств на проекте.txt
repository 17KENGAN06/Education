Начнем устанавливать пропсы, name="", salary={} во внутрь компонентов 

<EmployersListItem name = 'FGSDF' salary={7546}/>

employers-list-item.js остуновить нужно пропсы в атрибуты props , таким способом как props.name и props.salary 

Так же где зарплата в props.salary из-за того что пишем в бектиках можно добавить знак доллара с помощью + $ 

А теперь чтобы код выглядел лучше - принять нужно принцип деструктуризации 

А как же этих работников сгенерировать програмно?

Создаю имитацию базы данных, в файле app.js , 

const data [
    {name: 'Sasdf.f , salary: 800},
    {name: 'Sasdf.f , salary: 800},
    {name: 'Sasdf.f , salary: 800},
]

После в employersList я передаю <EmployersList data={data} /> который могу после использовать 

Я передаю его как props {data} , если бы мы были не сообразительны мы бы писали как data[0].name внутри элементов, это бы сработало - 
но вручную представь что нужно будет создавать тысячу их , это будет супер долго и для этого нузжно отдать их с помощью цикла 


с помощью map - это можно реализовать, он переберет и присвоит компонентам свои данные из масива данных , мне нужен тот который пройдет по масиву, сделает кое-что 
с каждым элементом и вернет новый масив элементов for each не подойдет потому что он просто перебирает масив и не отдает новый 

const EmployersList = {{data}} => {

    const elements = data.map(item => {
    return (
        <EmployersListItem name={item.name} salary={item.salary} />
        
        )
    })

    return (
        <ul className="app-list list-group">
                                                Сюда я подставляю {elements} который и будет генерить этих чувачков динамически 
        </ul>
    )
}

В этом крутость , то что данные тянутся и есть шаблонка, на которой висят пропсы - которые тянут данные


<EmployersListItem name={item.name} salary={item.salary} /> - заместо этой передачи данных - можно использовать спрес оператор {...item} - 
который передаст значение name = name, salary = salary 



// Практика 

У меня есть стили в employers-list-item.css которые отвечаю за попраску поля, а так же есть кнопка рядом с пользователем, нажимая на которую будет краситься пользователь ,

Как только у класса .list-group-item появляется класс increase, то применяются и другие классы - которые окрашивают 
пользователя в другой цвет. 

Задание выполнить так, если у пользователя есть поле increase со значение true - то пользователь должен быть окрашен в золотистый тот цвет 

Как я понял реализацию этого , создаю let classNames = 'куда помещаю классы' с лишки, а далее делаю проверку с помощью 
 
 if (increase) {
    className += ' increase' - обязательно пробел чтобы оно не срослось 
 }

 ипо если инкрис true то добавляю класс а если нет то остается как есть.