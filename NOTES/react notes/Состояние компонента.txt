Компоненты бывают классовые и функциональные , раньше в функциональных компонентах состояние 
создать было не возможно , они были только в классовых сейчас это можно сделать с помощью реак хукс, 
я это изучу позже 

Реакт начинался с состояния класса на компонентах 

Как я уже знаю чтобы работать с классами , нужно классу унаследовать поведение компонента из реакт 

import { Component } form 'react';

class WhoAmI extends Component {
    render() {
        <div>
            <h1>My name is {name} , surname - {surname}</h1>
            <a href={link}>My profile</a>
        </div>
    }
}


Так же вот есть компонент пользователя который будет выглядеть вот Так
<WhoAmI name='John' surname='Smith' link='facebook.com'/>

Теперь пропсы у нас есть, они передаются во внутрь компонента, он создает экземпляры классов, чтобы использовать 
пропсы в экземплярах классов - нам нужен конструктор , в этот конструктор приходит объект props и чтобы мы могли 
их использовать прописываем super , вот эта возможность работать с пропсами приходит из компонента теперь у каждого 
элемента который мы создали будет присутствовать this props c элементами которые мы туда передали 

class WhoAmI extends Component {

    construstor(props) {
        super(props);
    }
    render() {
        <div>
            <h1>My name is {name} , surname - {surname}</h1>
            <a href={link}>My profile</a>
        </div>
    }
}


чтобы убедиться в этом , я создаю const {name, surname, link} = this.props;

потом в консоле пишет что консруктор можно удалить ибо он бесполезный, т.к объект с пропсами в любом случае 
будет приходить ибо мы его и так передает, но я оставлю его ибо могут быть какие-то дополнительные действия 
в конструкторе. 

Пропсы только для чтения , их менять нельзя 

для того чтобы управлять их состоянием , нужно прописать 

construstor(props) {
        super(props);
        this.state = {
            years: 27
        }
    }

Это состояние с которым я буду работать и буду хранить его в этом объекте 

теперь это состояние применю внутри этого компонента 

<h1>My name is {name} , surname - {surname}, age - {this.state.years}</h1>

Сейчас я добавлю кнопку, с помощью которого добавлю событие 

<button onClick={this.nextYear}>+++</button>

Он клик это аналог адвансевентлисенер 

nextYear = () => {
    console.log('+++');
}

Подробнее как работают события в реакте и другие штуки разберем позже, сейчас добавим событие изменения 

Только стрелочную функцию можно использовать ибо иначе я получу ошибку 

nextYear = () => {
    this.state.years++; 
}

Можно предположить что если навешать такое событие - то будет изменяться возраст, но нет, напрямую менять значения 
нельзя 

Единственный правильный способ изменить состояние - это использовать 


nextYear = () => {
    this.setState({
     years: ++this.state.years;
    })
}

Тут мы говорим - что у нас есть свойство years и у нас тут будет текущее состояние только 
увеличенное на единичку , так же я сдедал этот префиксной формой.

Но, ошибка в консоле не уходит потому что мы текущее состояние мутируем и по этому когда мы хотим увеличить или 
уменьшить то лучше делать вот так 

nextYear = () => {
    this.setState({
     years: this.state.years + 1;
    })
}

И теперь сообщение уходит 

Подытожим, когда запускается команда с setState - она запускает 
перерисовку всего компонента с новым состояние (вызовом метода рендер )

Наше состояние будет зависеть от предыдущего стейта , команда setstate выполняется ассинхронно и может 
возникнуть проблема что предыдущее состояние ещё не обновилось, а мы его уже обновляем 

Допустим я быстро кликаю.. И почему же такое допускается

Из-за того что реакт работает на оптимизацию , допустим работает какой-то слождый этап и дабы не задерживать ничего
все работает ассинхоронно и из-за этого может выполниться немного позже, а чтобы этого избегать - можно 
воспользоваться колбек функцией 


nextYear = () => {
    this.setState(state => ({
     years: state.years + 1; - Если я буду работать со значение у которого мне важно предыдущее состояние - то я буду передавать с помощью колбек функции - это сохранить предыдущий результат 
    }))
}

Из-за того что state получает объект себя текущего this из-за этого убирается 

nextYear = () => {
    this.setState({
     years: this.state.years + 1; - а если с объектом допустим и инпута - то можно передать объектом 
    })
}

construstor(props) {
        super(props);
        this.state = {
            years: 27,
            text: '+++'
        }
    }
 

 если я в state добавил текст , который будет отображаться в какой-то кнопке, а years изменяется в 

 nextYear = () => {
    this.setState(state => ({
     years: state.years + 1; 
    }))
}

то он просто обходит текст, оставляет его в том же состояние и все хорошо работает 