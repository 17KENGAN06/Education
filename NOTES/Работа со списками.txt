По поводу ошибки, то что у каждого элемента должен быть ключ 

Одно из решений это использовать virtual dom , если представить что есть 200 пользователей и один из них удалился или добавился в середине - что нужно делать
Если представить что допустим обертка изменилась то реакт думает что весь элемент изменился и нужно будет по логике
отрисовать все заново , проще ведь отдать обновленные данные , но я ещё не знаю как это сделать, при этом если 
будет изменяться атрибует какой-то у элемента, то реакт будет их менять динамически 

Элемент ul уничтожится, внутрянка его остается, и потом отдастся новый изменившийся, а дальше реакт пойдет рекурсивно
и пойдет во внутрь него, проверять будет изменилось ли что-то внутри , сохранив копию но и при этом сохраняет новое
которое должно быть построено и теперь проверяются 2 версии на отличия - если реакт находит в них отличие то реакт 
создаст мутацию и он изменить только те элементы которые изменились 

Здесь если подумать есть небольшая проблема, допусти отдается база данных с пользователями, и если отдать пользователя
добавить его в конец, то реакт проверит данных, сверит что сверху ничего не изменялось и изменит последнего, но возникает
трудность если это же происходит вначале, добавился пользователь вначали или середину (и ломается нумерация , 
первый элемент стал вторым и т.д он будет думать что весь список изменился и будет перерисовывать все заново,
это удар по оптимизации )

Идентификатором что ничего не менялось есть KEY, с помощью него можно указать что все осталось прежним 

допустим у нас есть элемент объекта {name: 'John C.', salary: 800, increase: false, id: 1}

он и есть id , это как пример сейчас на проекте он будет уникальным ключом 

в переборе чтобы добавить его я указываю <EmployersListItem key={} {...item} />

чтобы достать эту айдишку, можно десткруктуризировать объект вытащив отдельно айдику и оставшиеся пропсы

const {id, ...itemProps} = item;

и потом в элемент добавляю так <EmployersListItem key={id} {...itemProps} />

После этого ошибка исчезает из консоли 

Теперь если что-то будет изменено, то из-за того что у каждого элемента есть своя идентификация - будет изменяться
только тот элемент который изменился, а не весь, из-за того что мы идентифицируем все элементы по айдишке 

Можно key добавить и так - 

const elements data.map(item, i) => {
    бла бла бла 

    где в <EmployersListItem key={i} {...itemProps} /> вместо айдишки передам i
}

И ошибка тоже исчезнет , но такое допускается только если я точно знаю что порядок этих элементов меняться не будет 
иначе нет смысл 

Так же считается плохой практикой рандомные key задавать , 

Если кто-то спросит зачем мне нужен key - для оптимизации приложения 

Все будет работать и без него, но я потеряю ту оптимизацию которая нужна

Суммирую реакт изменяет только те элементы которые изменились - в этом ему помогает алгоритм согласования 
При работе со списком одинаковых сущностей нужно использовать атрибут key , чаще всего я буду их встречать в 
методах перебора map